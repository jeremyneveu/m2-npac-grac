image: condaforge/mambaforge:latest

#variables:
# BASE_URL: "https://m2-npac-ac.pages.in2p3.fr/"  # "/m2-npac-ac"

cache:
  paths:
    - .cache/pip

stages:
  - build

before_script:
  - eval "$(mamba shell hook --shell bash)"
  - python -V               # Print out python version for debugging
 
pages:
  stage: build
  script:
    # - mamba install -y -c conda-forge nodejs pyyaml
    - mamba install -c conda-forge mystmd
    # - node -v
    # - npm install -g mystmd@latest
    - myst -v
    - cp myst.yml tmp_myst.yml
    #- rm myst.yml
    #- python remove_toc.py
    #- export BASE_URL="/m2-npac-ac"  # "https://m2-npac-ac.pages.in2p3.fr/"  # "/m2-npac-ac"
    #- git clone https://github.com/jupyter-book/mystmd-quickstart.git
    #- cd mystmd-quickstart
    #- myst init --site
    #- myst init --project
    # Approche alternative - build avec jupyter-book si MyST pose problème  
    - pip install jupyter-book
    # Créer un _config.yml minimal pour jupyter-book en cas de besoin
    - |
      cat > _config.yml << EOF
      title: 'M2 NPAC Cosmology'
      execute:
        execute_notebooks: off
      EOF
    # Générer _toc.yml automatiquement depuis myst.yml
    - |
      python3 << 'PYTHON_SCRIPT'
      import yaml
      import re
      
      # Lire le fichier myst.yml
      with open('myst.yml', 'r', encoding='utf-8') as f:
          myst_config = yaml.safe_load(f)
      
      def process_file_path(file_path):
          """Nettoie le chemin de fichier pour Jupyter Book"""
          if not file_path:
              return None
          # Supprimer l'extension pour Jupyter Book
          clean_path = re.sub(r'\.(md|ipynb)$', '', file_path)
          return clean_path
      
      def convert_myst_item_to_jb(item):
          """Convertit un élément MyST vers Jupyter Book"""
          if isinstance(item, str):
              return {'file': process_file_path(item)}
          
          if not isinstance(item, dict):
              return None
          
          jb_item = {}
          
          # Traiter le fichier
          if 'file' in item:
              file_path = process_file_path(item['file'])
              if file_path:
                  jb_item['file'] = file_path
          
          # Traiter le titre
          if 'title' in item:
              jb_item['title'] = item['title']
          
          # Traiter les enfants
          if 'children' in item and isinstance(item['children'], list) and item['children']:
              sections = []
              for child in item['children']:
                  converted_child = convert_myst_item_to_jb(child)
                  if converted_child:
                      sections.append(converted_child)
              if sections:
                  jb_item['sections'] = sections
          
          return jb_item if jb_item else None
      
      # Extraire la TOC de MyST
      myst_toc = myst_config.get('toc', [])
      
      # Créer la structure Jupyter Book
      jb_config = {
          'format': 'jb-book',
          'root': 'README',
          'chapters': []
      }
      
      # Traiter les éléments de la TOC
      if myst_toc and len(myst_toc) > 0:
          # Chercher les chapitres (skip README s'il est en premier)
          start_idx = 0
          if len(myst_toc) > 0 and isinstance(myst_toc[0], dict) and myst_toc[0].get('file') == 'README.md':
              start_idx = 1
          
          for item in myst_toc[start_idx:]:
              converted_item = convert_myst_item_to_jb(item)
              if converted_item:
                  jb_config['chapters'].append(converted_item)
      
      # S'assurer qu'on a au moins un chapitre
      if not jb_config['chapters']:
          # Fallback : ajouter quelques fichiers de base
          jb_config['chapters'] = [
              {'file': 'start'},
              {'file': 'chapters/fr/start'}
          ]
      
      # Écrire le fichier _toc.yml
      with open('_toc.yml', 'w', encoding='utf-8') as f:
          yaml.dump(jb_config, f, default_flow_style=False, allow_unicode=True, sort_keys=False)
      
      print("Generated _toc.yml from myst.yml structure")
      print(f"Generated {len(jb_config['chapters'])} chapters")
      
      # Debug: afficher le contenu généré
      with open('_toc.yml', 'r') as f:
          print("Generated _toc.yml content:")
          print(f.read())
      PYTHON_SCRIPT
    # Essayer MyST d'abord, puis jupyter-book en fallback
    - (timeout 60 myst build --html 2>/dev/null && echo "MyST build successful") || (echo "MyST failed, trying jupyter-book" && jupyter-book build . --path-output _build)
    - ls -la _build/
    # Trouver le répertoire de sortie HTML
    - if [ -d "_build/html" ]; then mv _build/html/ ../public; elif [ -d "_build/_build/html" ]; then mv _build/_build/html/ ../public; else echo "No HTML build found" && find _build -name "*.html" && exit 1; fi
    #- mv tmp_myst.yml myst.yml
    #- myst build --html
    #- mv _build/html/ public/fr
    #- sed -i 's@fr/@en/@g' myst.yml
    #- myst build --html
    #- mv _build/html/ public/en
    #- pip install jupyterlite-core jupyterlite-xeus jupyterlab notebook ipympl ipywidgets
    #- mamba install micromamba -c conda-forge
    #- rm -rf notebooks/TP_SN.ipynb
    #- jupyter lite build --XeusAddon.environment_file=jupyterlite-environment.yml --contents=notebooks --output-dir=public/lite
  artifacts:
    paths:
      - public
  only:
    - main

#docker:
#  image: docker:19.03.12
#  stage: build
#  services:
#    - docker:19.03.12-dind
#  variables:
#    IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG
#  script:
#    - cd docker
#    - ls -la .
#    # - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
#    - docker build -t $IMAGE_TAG . --file Dockerfile-CI
#    - docker push $IMAGE_TAG
#  #rules:
#  #  - changes:
#  #      - docker/*


